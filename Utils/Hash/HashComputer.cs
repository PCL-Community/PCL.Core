using System;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Runtime.InteropServices;

namespace PCL.Core.Utils.Hash;

public static class HashComputer
{
    /// <summary>
    /// Compute MurmurHash2 from a file.
    /// </summary>
    /// <param name="filePath">Target file path.</param>
    /// <returns>Computed hash number.</returns>
    /// <exception cref="FileNotFoundException">Throw if file not found.</exception>
    public static uint ComputeMurmur2(string filePath)
    {
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException("File not found.", Path.GetFileName(filePath));
        }

        using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);
        return ComputeMurmur2(fs);
    }

    /// <summary>
    /// 使用内存映射文件（Memory-Mapped File）为 FileStream 高效计算 MurmurHash2。<br/>
    /// 这是处理本地大文件的最佳性能实践。<br/>
    /// Generated by Gemini 2.5 Pro
    /// </summary>
    /// <param name="stream">要计算哈希值的文件流。</param>
    /// <exception cref="InvalidOperationException">Throw if pointer is null. Maybe out of memory.</exception>
    /// <returns>32位无符号哈希值。</returns>
    public static unsafe uint ComputeMurmur2(FileStream stream)
    {
        var length = stream.Length;
        if (length == 0)
        {
            return 0;
        }

        using var mmf = MemoryMappedFile.CreateFromFile(
            stream,
            mapName: null,
            capacity: 0,
            MemoryMappedFileAccess.Read,
            HandleInheritability.None,
            leaveOpen: true
        );
        using var accessor = mmf.CreateViewAccessor(0, length, MemoryMappedFileAccess.Read);
        byte* pointer = null;
        accessor.SafeMemoryMappedViewHandle.AcquirePointer(ref pointer);

        try
        {
            if (pointer == null)
            {
                // 在某些罕见情况下（如内存不足），可能无法获取指针
                throw new InvalidOperationException("Could not acquire pointer to the memory-mapped view.");
            }

            var data = new ReadOnlySpan<byte>(pointer, (int)length);

            return ComputeMurmur2(data);
        }
        finally
        {
            if (pointer != null)
            {
                accessor.SafeMemoryMappedViewHandle.ReleasePointer();
            }
        }
    }

    /// <summary>
    /// 使用 <see cref="Span{T}"/> 和 <see cref="MemoryMarshal"/> 实现的高性能、内存安全的MurmurHash2算法。<br/>
    /// Generated by Gemini 2.5 Pro
    /// </summary>
    /// <param name="data">要计算哈希值的数据跨度。</param>
    /// <returns>32位无符号哈希值。</returns>
    public static uint ComputeMurmur2(ReadOnlySpan<byte> data)
    {
        // 定义算法的幻数常量
        const uint m = 0x5BD1E995;
        const int r = 24;

        var length = data.Length;
        if (length == 0)
            return 0;

        var hash = (uint)length ^ 1; // 种子为1

        // 1. 主体循环 - 使用MemoryMarshal.Cast高效处理4字节块
        var numUInts = length / 4;
        if (numUInts > 0)
        {
            // 将byte span的前部（可被4整除的部分）重解释为uint span，无拷贝开销
            var uints = MemoryMarshal.Cast<byte, uint>(data[..(numUInts * 4)]);

            foreach (var k in uints)
            {
                var kMut = k; // 创建一个可变副本
                kMut *= m;
                kMut ^= kMut >> r;
                kMut *= m;

                hash *= m;
                hash ^= kMut;
            }
        }

        // 2. 尾部处理 - 处理最后 1-3 个字节
        var remainderIndex = numUInts * 4;
        var remainingBytes = length - remainderIndex;

        // 使用switch处理剩余部分
        switch (remainingBytes)
        {
            case 3:
                // C#的小端序架构下，前两个字节的组合与读取ushort等价
                hash ^= MemoryMarshal.Read<ushort>(data[remainderIndex..]);
                hash ^= (uint)data[remainderIndex + 2] << 16;
                hash *= m;
                break;
            case 2:
                hash ^= MemoryMarshal.Read<ushort>(data[remainderIndex..]);
                hash *= m;
                break;
            case 1:
                hash ^= data[remainderIndex];
                hash *= m;
                break;
        }

        // 3. 最终混合
        hash ^= hash >> 13;
        hash *= m;
        hash ^= hash >> 15;

        return hash;
    }

    /// <summary>
    /// Compute file SHA1 from file path.
    /// </summary>
    /// <returns>Computed SHA1.</returns>
    /// <exception cref="FileNotFoundException">Throw if file not found.</exception>
    public static string ComputeSha1(string filePath)
    {
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException("File not found.", Path.GetFileName(filePath));
        }

        using var fs = new FileStream(filePath, FileMode.Open, FileAccess.Read);
        return ComputeSha1(fs);
    }

    /// <summary>
    /// Comput file SHA1 from <see cref="FileStream"/>.
    /// </summary>
    /// <returns>Computed SHA1.</returns>
    public static string ComputeSha1(FileStream fileStream) =>
        SHA1Provider.Instance.ComputeHash(fileStream);
}