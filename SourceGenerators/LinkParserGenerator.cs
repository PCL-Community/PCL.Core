using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
// 添加缺失的命名空间引用
using System.Collections.Immutable;

namespace PCL.Core.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class LinkParserGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 查找所有带有 ParserAttribute 的类
        var parserClasses = context.SyntaxProvider.CreateSyntaxProvider(
            static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
            static (ctx, _) => _GetParserClass(ctx)
        )
            .Where(static m => m is not null);

        // 收集所有 Parser 类并生成代码
        var compilationAndClasses = context.CompilationProvider.Combine(parserClasses.Collect());
        
        context.RegisterSourceOutput(compilationAndClasses, (ctx, source) => _GenerateCode(ctx, source.Right));
    }

    private static object? _GetParserClass(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classSyntax);
        if (classSymbol == null) return null;

        // 检查类是否有 ParserAttribute - 通过名称匹配
        var hasParserAttribute = classSymbol.GetAttributes().Any(attr =>
            attr.AttributeClass != null &&
            attr.AttributeClass.Name == "ParserAttribute");

        // 添加调试信息
        if (hasParserAttribute)
        {
            return classSymbol;
        }
        
        // 检查所有属性名称用于调试
        foreach (var attr in classSymbol.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "Parser")
            {
                return classSymbol;
            }
        }

        return null;
    }

    private static void _GenerateCode(SourceProductionContext context, ImmutableArray<object?> parserClasses)
    {
        var sb = new StringBuilder();

        // 添加文件头注释
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace PCL.Core.Link.Lobby.Parser;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// 解析器注册表, 用于自动注册所有标记了 ParserAttribute 特性的解析器类");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class ParserRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// 所有解析器类型的列表");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static readonly List<Type> ParserTypes = new List<Type>");
        sb.AppendLine("    {");

        // 添加所有找到的解析器类型
        foreach (var parserClass in parserClasses)
        {
            if (parserClass is not INamedTypeSymbol namedTypeSymbol) continue;
            var fullTypeName = namedTypeSymbol.ToDisplayString();
            sb.AppendLine($"        typeof({fullTypeName}),");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        context.AddSource("ParserRegistry.g.cs", sb.ToString());
    }
}