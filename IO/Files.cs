using System;
using System.IO;
using System.Text;
using PCL.Core.Logging;
using PCL.Core.Utils;

namespace PCL.Core.IO;

public static class Files {
    /// <summary>
    /// 在指定路径创建一个指向目标文件的 .lnk 快捷方式。
    /// </summary>
    /// <param name="shortcut">要创建的快捷方式完整路径，建议以 ".lnk" 结尾</param>
    /// <param name="target">被指向的目标文件或可执行程序路径</param>
    /// <param name="arguments">启动时的命令行参数</param>
    /// <param name="workingDirectory">快捷方式的起始目录</param>
    /// <param name="description">快捷方式说明</param>
    /// <param name="icon">自定义图标，格式 "图标文件路径,索引"</param>
    // Partly generated by o4-mini-high (20250719)
    public static void CreateShortcut(
        string shortcut,
        string target,
        string? arguments = null,
        string? workingDirectory = null,
        string? description = null,
        string? icon = null) {
        if (string.IsNullOrWhiteSpace(shortcut))
            throw new ArgumentException("shortcutPath 不能为空", nameof(shortcut));
        if (string.IsNullOrWhiteSpace(target))
            throw new ArgumentException("targetFilePath 不能为空", nameof(target));

        // 确保目录存在
        var dir = Path.GetDirectoryName(shortcut);
        if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir)) Directory.CreateDirectory(dir);

        // 与 WshShell 交互
        var shellType = Type.GetTypeFromProgID("WScript.Shell", throwOnError: true)!;
        dynamic shell = Activator.CreateInstance(shellType)!;
        var link = shell.CreateShortcut(shortcut)!;

        // 设置属性
        link.TargetPath = target;
        if (!string.IsNullOrEmpty(arguments)) link.Arguments = arguments;
        if (!string.IsNullOrEmpty(workingDirectory)) link.WorkingDirectory = workingDirectory;
        else link.WorkingDirectory = Path.GetDirectoryName(target) ?? Path.GetPathRoot(target);
        if (!string.IsNullOrEmpty(description)) link.Description = description;
        if (!string.IsNullOrEmpty(icon)) link.IconLocation = icon;

        // 保存 .lnk 文件
        link.Save();
    }

    /// <summary>
    /// 获取完整的文件路径。如果是相对路径，补全为 "Path\filePath"。
    /// </summary>
    private static string GetFullPath(string filePath) {
        ArgumentNullException.ThrowIfNull(filePath);
        return filePath.Contains(":\\") ? filePath : Path.Combine(Paths.ExePath, filePath);
    }

    /// <summary>
    /// 复制文件，自动创建目标目录并覆盖已有文件。
    /// </summary>
    /// <param name="fromPath">源文件路径（完整或相对）。</param>
    /// <param name="toPath">目标文件路径（完整或相对）。</param>
    /// <exception cref="Exception">复制失败时抛出。</exception>
    public static void CopyFile(string fromPath, string toPath) {
        try { 
            var fullFromPath = GetFullPath(fromPath);
            var fullToPath = GetFullPath(toPath);
            if (fullFromPath == fullToPath) return;

            Directory.CreateDirectory(System.IO.Path.GetDirectoryName(fullToPath) ?? throw new InvalidOperationException("无法获取目标目录"));
            File.Copy(fullFromPath, fullToPath, overwrite: true);
        } catch (Exception ex) {
            throw new Exception($"复制文件出错：{fromPath} → {toPath}", ex);
        }
    }

    /// <summary>
    /// 读取文件为字节数组，失败时返回空数组。支持读取被占用的文件。
    /// </summary>
    /// <param name="filePath">文件路径（完整或相对）。</param>
    /// <returns>文件内容的字节数组，失败时返回空数组。</returns>
    public static byte[] ReadFileBytes(string filePath) {
        try {
            var fullPath = GetFullPath(filePath);
            if (File.Exists(fullPath)) {
                using var stream = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                using var memoryStream = new MemoryStream();
                stream.CopyTo(memoryStream);
                return memoryStream.ToArray();
            }

            LogWrapper.Info($"欲读取的文件不存在，已返回空内容：{filePath}");
            return [];
        } catch (Exception ex) {
            LogWrapper.Warn(ex, $"读取文件出错：{filePath}");
            return [];
        }
    }

    /// <summary>
    /// 读取文件为字符串，失败时返回空字符串。
    /// </summary>
    /// <param name="filePath">文件路径（完整或相对）。</param>
    /// <param name="encoding">文件编码（可选）。</param>
    /// <returns>文件内容的字符串，失败时返回空字符串。</returns>
    public static string ReadFile(string filePath, Encoding? encoding = null) {
        var fileBytes = ReadFileBytes(filePath);
        return encoding == null ? EncodingUtils.DecodeBytes(fileBytes) : encoding.GetString(fileBytes);
    }

    /// <summary>
    /// 从流中读取所有文本。
    /// </summary>
    /// <param name="stream">要读取的流。</param>
    /// <param name="encoding">文件编码（可选，若为 null 则动态检测）。</param>
    /// <returns>流内容的字符串，失败时返回空字符串。</returns>
    public static string ReadFile(Stream stream, Encoding? encoding = null) {
        try {
            ArgumentNullException.ThrowIfNull(stream);
            using var memoryStream = new MemoryStream();
            stream.CopyTo(memoryStream);
            var bytes = memoryStream.ToArray();
            return (encoding ?? EncodingDetector.DetectEncoding(bytes)).GetString(bytes);
        } catch (Exception ex) {
            LogWrapper.Warn(ex, "读取流出错");
            return "";
        }
    }

    /// <summary>
    /// 写入字符串到文件，支持追加或覆盖，自动创建目录。
    /// </summary>
    /// <param name="filePath">文件路径（完整或相对）。</param>
    /// <param name="text">要写入的文本。</param>
    /// <param name="append">是否追加到文件（true）或覆盖（false）。</param>
    /// <param name="encoding">文件编码（可选）。</param>
    public static void WriteFile(string filePath, string text, bool append = false, Encoding? encoding = null) {
        var fullPath = GetFullPath(filePath);
        Directory.CreateDirectory(Path.GetDirectoryName(fullPath) ?? throw new InvalidOperationException("无法获取目标目录"));

        if (append) {
            encoding ??= EncodingDetector.DetectEncoding(ReadFileBytes(filePath));
            File.AppendAllText(fullPath, text, encoding);
        } else {
            encoding ??= new UTF8Encoding(false); // 无 BOM 的 UTF-8
            File.WriteAllText(fullPath, text, encoding);
        }
    }

    /// <summary>
    /// 写入字节数组到文件，自动创建目录。
    /// </summary>
    /// <param name="filePath">文件路径（完整或相对）。</param>
    /// <param name="content">要写入的字节数组。</param>
    /// <param name="append">是否追加到文件（true）或覆盖（false）。</param>
    public static void WriteFile(string filePath, byte[] content, bool append = false) {
        var fullPath = GetFullPath(filePath);
        Directory.CreateDirectory(Path.GetDirectoryName(fullPath) ?? throw new InvalidOperationException("无法获取目标目录"));

        if (append) {
            using var fileStream = new FileStream(fullPath, FileMode.Append, FileAccess.Write);
            fileStream.Write(content, 0, content.Length);
        } else {
            File.WriteAllBytes(fullPath, content);
        }
    }

    /// <summary>
    /// 将流写入文件，自动创建目录。
    /// </summary>
    /// <param name="filePath">文件路径（完整或相对）。</param>
    /// <param name="stream">要写入的流。</param>
    /// <returns>写入是否成功。</returns>
    public static bool WriteFile(string filePath, Stream stream) {
        try {
            ArgumentNullException.ThrowIfNull(stream);
            var fullPath = GetFullPath(filePath);
            Directory.CreateDirectory(Path.GetDirectoryName(fullPath) ?? throw new InvalidOperationException("无法获取目标目录"));

            using var fileStream = new FileStream(fullPath, FileMode.Create, FileAccess.Write);
            fileStream.SetLength(0);
            stream.CopyTo(fileStream);
            return true;
        } catch (Exception ex) {
            LogWrapper.Warn(ex, "保存流出错");
            return false;
        }
    }
}
