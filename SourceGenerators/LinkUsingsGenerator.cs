using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
// 添加缺失的命名空间引用
using System.Collections.Immutable;

namespace PCL.Core.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class LinkUsingsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 查找所有带有 ParserAttribute 的类
        var parserClasses = context.SyntaxProvider.CreateSyntaxProvider(
            static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
            static (ctx, _) => _GetParserClass(ctx)
        )
            .Where(static m => m is not null);

        // 收集所有 Parser 类并生成代码
        var compilationAndClasses = context.CompilationProvider.Combine(parserClasses.Collect());
        
        context.RegisterSourceOutput(compilationAndClasses, (ctx, source) =>
        {
            _GenerateCode(ctx, source.Right);
        });
    }

    private static object? _GetParserClass(GeneratorSyntaxContext context)
    {
        var classSyntax = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classSyntax);
        if (classSymbol == null) return null;
    
        // 检查类是否有 ParserAttribute - 通过完全限定名精确匹配，避免名称冲突
        var parserAttributeSymbol = context
            .SemanticModel
            .Compilation
            .GetTypeByMetadataName("PCL.Core.Link.Lobby.Parser.ParserAttribute");
        if (parserAttributeSymbol == null) return null;
    
        return classSymbol.GetAttributes().Any(attr =>
            SymbolEqualityComparer.Default.Equals(attr.AttributeClass, parserAttributeSymbol)) 
            ? classSymbol 
            : null;
    }

    private static void _GenerateCode(SourceProductionContext context, ImmutableArray<object?> parserClasses)
    {
        var sb = new StringBuilder();

        // 添加文件头注释
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using PCL.Core.Link.Lobby.Parser;");
        sb.AppendLine();
        sb.AppendLine("namespace PCL.Core.Link.Lobby;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// 用于放置联机需要用到的一些数据");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class LinkUsings");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// 所有解析器实例的列表");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static readonly List<ILobbyIdParser> Parsers = new List<ILobbyIdParser>");
        sb.AppendLine("    {");

        // 添加所有找到的解析器类型
        foreach (var parserClass in parserClasses)
        {
            if (parserClass is not INamedTypeSymbol namedTypeSymbol) continue;
            var fullTypeName = namedTypeSymbol.ToDisplayString();
            sb.AppendLine($"        new {fullTypeName}() as ILobbyIdParser,");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        context.AddSource("LinkUsings.g.cs", sb.ToString());
    }
}