using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

namespace PCL.Core.SourceGenerators;

[Generator]
public class EnvironmentInteropGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 从 MSBuild 属性中提取所有 PCL_* 配置
        var secretProperties = context.AnalyzerConfigOptionsProvider
            .Select(static (options, _) => _ReadSecretProperties(options));

        // 注册源代码生成
        context.RegisterSourceOutput(secretProperties, _GenerateSource);
    }

    private static Dictionary<string, string> _ReadSecretProperties(AnalyzerConfigOptionsProvider options)
    {
        var secrets = new Dictionary<string, string>();

        // 我们希望读取形如 -p:PCL_MS_CLIENT_ID=value 的 MSBuild 属性
        // 在 Source Generator 中对应的是：build_property.PCL_XXX
        var prefix = "build_property.PCL_";

        foreach (var key in new[]
        {
            "WRITE_SECRET",
            "MS_CLIENT_ID",
            "CURSEFORGE_API_KEY",
            "TELEMETRY_KEY",
            "NAID_CLIENT_ID",
            "NAID_CLIENT_SECRET",
            "LINK_SERVER_ROOT",
            "LOBBY_DEFAULT_SECRET",
            "GITHUB_SHA",
        })
        {
            var fullKey = prefix + key;
            if (options.GlobalOptions.TryGetValue(fullKey, out var value) && !string.IsNullOrEmpty(value))
            {
                // 去掉 PCL_ 前缀，只保留后半部分作为字典 key
                var dictKey = key; // 例如 MS_CLIENT_ID
                secrets[dictKey] = value;
            }
        }

        // 只有当 WRITE_SECRET 存在时才输出 secrets
        return secrets.Remove("WRITE_SECRET")
            ? secrets // 移除控制开关本身
            : new Dictionary<string, string>(); // 返回空，不生成内容
    }

    private static void _GenerateSource(SourceProductionContext context, Dictionary<string, string> secrets)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改");
        sb.AppendLine("// 生成时间: " + DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC"));
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace PCL.Core.Utils.OS;");
        sb.AppendLine();
        sb.AppendLine("partial class EnvironmentInterop");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly System.Collections.Generic.Dictionary<string, string?> SecretDictionary = new()");
        sb.AppendLine("    {");

        foreach (var secret in secrets)
        {
            var verbatimValue = _ToVerbatimString(secret.Value);
            sb.AppendLine($"        [\"{secret.Key}\"] = {verbatimValue},");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        context.AddSource("EnvironmentInterop.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string _ToVerbatimString(string text)
    {
        // 转义双引号: " → ""
        var escaped = text.Replace("\"", "\"\"");
        return $"@\"{escaped}\"";
    }
}