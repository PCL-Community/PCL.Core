// NOTE: THIS WAS GENERATED BY GEMINI 2.5 PRO

using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;

namespace PCL.Core.Minecraft.Compoment.Entities;

public enum VersionType
{
    Special,
    Snapshot,
    Standard
}

public enum VersionEra
{
    Classic,
    Indev,
    Infdev,
    Alpha,
    Beta,
    Release
}

public enum PreReleaseStage
{
    Experimental = -1,
    Snapshot = 0,
    Pre = 1,
    Rc = 2,
    Release = 3
}

/// <summary>
/// 一个功能强大的、可比较的 Minecraft 版本记录。
/// 能够表示和排序标准版、Alpha/Beta、快照和特殊版本。
/// </summary>
public record MinecraftVersion : IComparable<MinecraftVersion>
{
    // --- 正则表达式定义 (按尝试顺序) ---
    private static readonly Regex _SnapshotRegex = new(@"^(?<year>\d{2})w(?<week>\d{2})(?<rev>[a-z])$",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    private static readonly Regex _StandardRegex = new(
        @"^(?:(?<era>[ab])(?<major>\d+)\.(?<minor>\d+)(?:\.(?<patch>\d+))?|(?<major>\d+)\.(?<minor>\d+)(?:\.(?<patch>\d+))?)(?:-?(?<stage>experimental|snapshot|pre|rc)(?<stagever>\d+)?)?",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    // --- 属性 ---
    public string RawValue { get; init; }
    public VersionType Type { get; init; }

    // Standard 版本属性
    public VersionEra Era { get; init; } = VersionEra.Release;
    public int Major { get; init; }
    public int Minor { get; init; }
    public int Patch { get; init; }
    public PreReleaseStage Stage { get; init; } = PreReleaseStage.Release;
    public int StageVersion { get; init; }

    // Snapshot 版本属性
    public int Year { get; init; }
    public int Week { get; init; }
    public char RevisionChar { get; init; }

    // 私有构造函数，只能通过工厂方法创建
    private MinecraftVersion(string rawValue)
    {
        this.RawValue = rawValue;
    }

    /// <summary>
    /// 核心比较逻辑，现在可以处理不同类型的版本。
    /// </summary>
    public int CompareTo(MinecraftVersion? other)
    {
        if (other is null) return 1;

        // 1. 按类型比较 (Standard > Snapshot > Special)
        if (Type != other.Type) return other.Type.CompareTo(Type);

        switch (Type)
        {
            case VersionType.Standard:
                // 2. 按时期比较 (Release > Beta > Alpha > ...)
                if (Era != other.Era) return Era.CompareTo(other.Era);
                // 3. 按数字版本号比较
                if (Major != other.Major) return Major.CompareTo(other.Major);
                if (Minor != other.Minor) return Minor.CompareTo(other.Minor);
                if (Patch != other.Patch) return Patch.CompareTo(other.Patch);
                // 4. 按预发布阶段比较
                if (Stage != other.Stage) return Stage.CompareTo(other.Stage);
                if (StageVersion != other.StageVersion) return StageVersion.CompareTo(other.StageVersion);
                break;

            case VersionType.Snapshot:
                // 比较快照版本
                if (Year != other.Year) return Year.CompareTo(other.Year);
                if (Week != other.Week) return Week.CompareTo(other.Week);
                if (RevisionChar != other.RevisionChar) return RevisionChar.CompareTo(other.RevisionChar);
                break;

            case VersionType.Special:
                // 对于特殊版本，只能进行简单的字符串比较作为回退
                return string.Compare(RawValue, other.RawValue, StringComparison.OrdinalIgnoreCase);
        }

        return 0;
    }

    /// <summary>
    /// 强大的工厂方法，采用分层解析策略。
    /// </summary>
    public static bool TryParse(string? versionString, [NotNullWhen(true)] out MinecraftVersion? version)
    {
        version = null;
        if (string.IsNullOrWhiteSpace(versionString)) return false;

        var cleanedString = versionString.ToLowerInvariant().Trim();

        // 策略 1: 尝试解析为快照版本 (e.g., "22w11a")
        var snapshotMatch = _SnapshotRegex.Match(cleanedString);
        if (snapshotMatch.Success)
        {
            version = new MinecraftVersion(versionString)
            {
                Type = VersionType.Snapshot,
                Year = int.Parse(snapshotMatch.Groups["year"].Value),
                Week = int.Parse(snapshotMatch.Groups["week"].Value),
                RevisionChar = snapshotMatch.Groups["rev"].Value[0]
            };
            return true;
        }

        // 策略 2: 尝试解析为标准/早期版本 (e.g., "1.18.2", "b1.7.3")
        var standardMatch = _StandardRegex.Match(cleanedString.Replace("预览版", "pre"));
        if (standardMatch.Success)
        {
            var era = VersionEra.Release;
            if (standardMatch.Groups["era"].Success)
            {
                era = standardMatch.Groups["era"].Value switch
                {
                    "a" => VersionEra.Alpha, "b" => VersionEra.Beta, _ => era
                };
            }

            var stage = PreReleaseStage.Release;
            if (standardMatch.Groups["stage"].Success)
            {
                stage = standardMatch.Groups["stage"].Value switch
                {
                    "experimental" => PreReleaseStage.Experimental,
                    "snapshot" => PreReleaseStage.Snapshot,
                    "pre" => PreReleaseStage.Pre,
                    "rc" => PreReleaseStage.Rc,
                    _ => stage
                };
            }

            version = new MinecraftVersion(versionString)
            {
                Type = VersionType.Standard,
                Era = era,
                Major = int.Parse(standardMatch.Groups["major"].Value),
                Minor = int.Parse(standardMatch.Groups["minor"].Value),
                Patch = standardMatch.Groups["patch"].Success ? int.Parse(standardMatch.Groups["patch"].Value) : 0,
                Stage = stage,
                StageVersion = standardMatch.Groups["stagever"].Success &&
                               int.TryParse(standardMatch.Groups["stagever"].Value, out var sv)
                    ? sv
                    : 0
            };
            return true;
        }

        // 策略 3: 作为回退，标记为特殊版本 (e.g., "20w14infinite")
        version = new MinecraftVersion(versionString) { Type = VersionType.Special };
        return true;
    }

    public override string ToString() => RawValue;
}