using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace PCL.Core.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class ArgumentsHandlersGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var handlerClassProvider = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => s is MethodDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => _GetArgumentHandlers(ctx))
            .Where(static x => x is not null);
        
        var handlersProvider = handlerClassProvider.Collect();
        
        context.RegisterSourceOutput(handlersProvider, _Generate);
    }
    
    private static ArgumentHandlerInfo? _GetArgumentHandlers(GeneratorSyntaxContext context)
    {
        var methodDeclaration = (MethodDeclarationSyntax)context.Node;

        var handlerAttribute = methodDeclaration.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a => a.Name.ToString().Contains("ArgumentHandler"));

        if (handlerAttribute == null) return null;

        if (context.SemanticModel.GetDeclaredSymbol(methodDeclaration) is not IMethodSymbol symbol) return null;
        
        if (!symbol.IsStatic) return null; // 仅处理静态方法
        
        if (!symbol.ReturnType.ToString().Contains("HandleResult")) return null; // 返回类型不匹配
        
        if (symbol.Parameters.Length != 1) return null; // 参数数量不匹配
        
        if (!symbol.Parameters[0].Type.ToString().Contains("string[]")) return null; // 参数类型不匹配

        if (handlerAttribute.ArgumentList == null) return null;

        // 解析第一个参数 (标识符)
        var identifier = "Unknown";
        var firstArg = handlerAttribute.ArgumentList.Arguments.FirstOrDefault();
        if (firstArg != null)
        {
            var constValue = context.SemanticModel.GetConstantValue(firstArg.Expression);
            if (constValue is { HasValue: true, Value: string strValue })
            {
                identifier = strValue;
            }
        }

        var parts = symbol.ToDisplayParts();
        var strParts = string.Empty;
        foreach (var part in parts)
        {
            strParts += part.ToString();
            if (part.Kind == SymbolDisplayPartKind.MethodName) break; // 只需要到方法名为止
        }

        // 生成信息
        return new ArgumentHandlerInfo(identifier, $"{strParts}");
    }

    private static void _Generate(SourceProductionContext context, ImmutableArray<ArgumentHandlerInfo?> handlers)
    {
        if (handlers == null) return;

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("// 此文件由 Source Generator 自动生成，请勿手动修改");
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine();
        builder.AppendLine("namespace PCL.Core.App;");
        builder.AppendLine("public sealed partial class ArgumentsService");
        builder.AppendLine("{");
        builder.AppendLine("    private void _Initialize()");
        builder.AppendLine("    {");
        foreach (var handler in handlers)
        {
            builder.AppendLine($"       _handlers.Add(\"{handler!.Identifier}\", {handler.FullName});");
        }
        builder.AppendLine("    }");
        builder.AppendLine("}");
        context.AddSource("ArgumentsService.g.cs", builder.ToString());
    }

    // 居然没法 record, 想骂人
    private class ArgumentHandlerInfo(string identifier, string fullName)
    {
        public string Identifier { get; } = identifier;
        public string FullName { get; } = fullName;
    }
}