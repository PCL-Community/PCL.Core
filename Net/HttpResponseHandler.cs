using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace PCL.Core.Net;

//Generated by DeepSeek R1
public class HttpResponseHandler(HttpResponseMessage responseMessage) : IDisposable
{
    private readonly HttpResponseMessage _responseMessage = responseMessage ?? throw new ArgumentNullException(nameof(responseMessage));

    public bool IsSuccess => _responseMessage.IsSuccessStatusCode;

    public HttpStatusCode StatusCode => _responseMessage.StatusCode;

    public string ReasonPhrase => _responseMessage.ReasonPhrase ?? string.Empty;

    public string AsStringContent()
    {
        return AsStringAsync().GetAwaiter().GetResult();
    }

    public async Task<string> AsStringAsync()
    {
        try
        {
            return await _responseMessage.Content
                .ReadAsStringAsync()
                .ConfigureAwait(false);
        }
        catch (TaskCanceledException)
        {
            throw new TimeoutException("The request was canceled due to a timeout.");
        }
        catch (OperationCanceledException)
        {
            throw new TimeoutException("The operation was canceled.");
        }
    }

    public async Task<Stream> AsStreamAsync()
    {
        try
        {
            return await _responseMessage.Content
                .ReadAsStreamAsync()
                .ConfigureAwait(false);
        }
        catch (TaskCanceledException)
        {
            throw new TimeoutException("The request was canceled due to a timeout.");
        }
        catch (OperationCanceledException)
        {
            throw new TimeoutException("The operation was canceled.");
        }
    }

    public async Task<byte[]> AsByteArrayAsync()
    {
        try
        {
            return await _responseMessage.Content
                .ReadAsByteArrayAsync()
                .ConfigureAwait(false);
        }
        catch (TaskCanceledException)
        {
            throw new TimeoutException("The request was canceled due to a timeout.");
        }
        catch (OperationCanceledException)
        {
            throw new TimeoutException("The operation was canceled.");
        }
    }

    public async Task<T?> AsJsonAsync<T>(JsonSerializerOptions? options = null, CancellationToken cancellationToken = default)
    {
        try
        {
            await using var stream = await AsStreamAsync().ConfigureAwait(false);
            return await JsonSerializer.DeserializeAsync<T>(stream, options, cancellationToken)
                .ConfigureAwait(false);
        }
        catch (JsonException ex)
        {
            throw new InvalidDataException("Failed to deserialize JSON response.", ex);
        }
    }

    public Dictionary<string, string[]> GetHeaders()
    {
        return _responseMessage.Headers
            .Concat(_responseMessage.Content.Headers)
            .ToDictionary(k => k.Key, v => v.Value.ToArray());
    }

    public Dictionary<string, string[]> GetContentHeaders()
    {
        return _responseMessage.Content.Headers
            .ToDictionary(k => k.Key, v => v.Value.ToArray());
    }

    public string[] GetHeader(string name)
    {
        if (_responseMessage.Headers.TryGetValues(name, out var values) || _responseMessage.Content.Headers.TryGetValues(name, out values))
            return values.ToArray();

        return [];
    }

    public bool TryGetHeader(string name, out string[] values)
    {
        if (_responseMessage.Headers.TryGetValues(name, out var headerValues) ||
            _responseMessage.Content.Headers.TryGetValues(name, out headerValues))
        {
            values = headerValues.ToArray();
            return true;
        }

        values = [];
        return false;
    }

    public string? GetFirstHeaderValue(string name)
    {
        return GetHeader(name).FirstOrDefault();
    }

    public bool TryGetFirstHeaderValue(string name, out string value)
    {
        var values = GetHeader(name);
        if (values.Length == 0)
        {
            value = string.Empty;
            return false;
        }
        value = values.First();
        return true;
    }

    public void EnsureSuccessStatusCode()
    {
        if (!IsSuccess)
        {
            throw new HttpRequestException(
                $"HTTP request failed with status code {_responseMessage.StatusCode}: {_responseMessage.ReasonPhrase}");
        }
    }

    public async Task EnsureSuccessStatusCodeWithContentAsync()
    {
        if (!IsSuccess)
        {
            var content = await AsStringAsync().ConfigureAwait(false);
            throw new HttpRequestException(
                $"HTTP request failed with status code {_responseMessage.StatusCode}: {_responseMessage.ReasonPhrase}. Response content: {content}");
        }
    }

    public HttpResponseMessage GetRaw() => responseMessage;

    private bool _disposed;

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;
        if (disposing)
        {
            _responseMessage.Dispose();
        }
        _disposed = true;
    }

    ~HttpResponseHandler()
    {
        Dispose(false);
    }
}